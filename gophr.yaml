# Made for ESPHome compliant configuration
# Gophr - Solar-Powered Moisture Sensor Device

substitutions:
  name: "gophr"
  friendly_name: "Gophr"
  software_version: "1.0.0"

esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"
  name_add_mac_suffix: true
  project:
    name: "FluxOpenHome.Gophr"
    version: "${software_version}"
  on_boot:
    priority: -100
    then:
      # Power up sensors and enable LED
      - output.turn_on: sensor_enable_pin
      - delay: 30s  # Wait 30 seconds after enabling GPIO6
      - output.turn_on: aht20_enable_pin
      - output.turn_on: led_enable_pin
      - delay: 15s

      # Set initial LED state
      - light.turn_on:
          id: status_led
          brightness: 50%
          red: 0%
          green: 0%
          blue: 100%
          effect: "Pulse"

      # Wait for sensor readings to be valid
      - wait_until:
          condition:
            and:
              - sensor.in_range:
                  id: moisture_1
                  above: 0.9
              - sensor.in_range:
                  id: moisture_2
                  above: 0.9
              - sensor.in_range:
                  id: moisture_3
                  above: 0.9
          timeout: 30s

      # Initialize boot state
      - lambda: |-
          ESP_LOGI("boot", "Boot complete");
          id(awake_start_time) = millis();

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf
    version: recommended

logger:
  id: logger_component
  level: DEBUG
  logs:
    sensor: DEBUG
    adc: DEBUG
    template.sensor: DEBUG
    esphome.components.template.sensor: DEBUG
    i2c: DEBUG
    aht10: DEBUG
    esphome.components.i2c: DEBUG

api:
  id: api_server
  on_client_connected:
    - logger.log: "HA connected"
    - light.turn_on:
        id: status_led
        brightness: 50%
        red: 0%
        green: 100%
        blue: 0%
        effect: "None"
    - lambda: |-
        if (!id(sleep_sequence_active)) {
          id(awake_start_time) = millis();
          ESP_LOGI("awake", "HA connected - awake_start_time reset");
        }

ota:
  - id: ota_component
    platform: esphome

dashboard_import:
  package_import_url: github://FluxOpenHome/Gophr/gophr.yaml@main
  import_full_config: true

wifi:
  id: wifi_component
  ap:
    ssid: "${name}"
  on_connect:
    - if:
        condition:
          lambda: 'return !id(sleep_sequence_active);'
        then:
          - light.turn_on:
              id: status_led
              brightness: 30%
              red: 0%
              green: 100%
              blue: 0%
              effect: "None"
          - logger.log: "WiFi connected - green LED"
    - lambda: |-
        id(wifi_sta_connected) = true;
        ESP_LOGI("wifi", "STA connected: sleep is now allowed");
  on_disconnect:
    - if:
        condition:
          lambda: 'return !id(sleep_sequence_active);'
        then:
          - light.turn_on:
              id: status_led
              brightness: 30%
              red: 0%
              green: 0%
              blue: 100%
              effect: "Pulse"
          - logger.log: "WiFi disconnected - blue pulsing LED"
    - lambda: |-
        id(wifi_sta_connected) = false;
        ESP_LOGW("wifi", "STA disconnected: sleep is now blocked");

captive_portal:
  id: captive_portal_component

esp32_improv:
  id: esp32_improv_component
  authorizer: none

improv_serial:
  id: improv_serial_component
  next_url: http://{{ip_address}}

web_server:
  id: web_server_component
  port: 80

preferences:
  flash_write_interval: 1min

deep_sleep:
  id: deep_sleep_component
  sleep_duration: 60min

time:
  - platform: homeassistant
    id: homeassistant_time

interval:
  # Check sleep conditions every 30 seconds
  - interval: 30s
    then:
      - lambda: |-
          if (id(sleep_sequence_active)) return;

          // --- HARD GATE: never sleep unless STA Wi-Fi is connected ---
          if (!id(wifi_sta_connected)) return;

          // Don't sleep if sleep is disabled
          if (id(sleep_disabled)) return;

          unsigned long now = millis();
          unsigned long awake_time_ms = now - id(awake_start_time);
          unsigned long max_awake_ms = id(max_awake_minutes) * 60UL * 1000UL;

          bool should_sleep = false;

          // Force sleep if max awake time exceeded
          if (awake_time_ms > max_awake_ms) {
            ESP_LOGI("sleep_check", "Max awake time exceeded (%d min) - forcing sleep", id(max_awake_minutes));
            should_sleep = true;
          }
          // Sleep after min awake time
          else if (awake_time_ms > (id(min_awake_minutes) * 60UL * 1000UL)) {
            ESP_LOGI("sleep_check", "Min awake reached (%d min) - going to sleep", id(min_awake_minutes));
            should_sleep = true;
          }

          if (!should_sleep) return;

          // Initiate sleep sequence
          ESP_LOGI("sleep", "Initiating sleep sequence");
          id(sleep_sequence_active) = true;
          id(sleep_sequence_start_time) = millis();
          id(last_m1_value) = id(moisture_1).state;
          id(last_m2_value) = id(moisture_2).state;
          id(last_m3_value) = id(moisture_3).state;

          // Turn off sensors, LED, and mark device as not awake
          id(sensor_enable_pin).turn_off();
          id(aht20_enable_pin).turn_off();
          id(device_awake) = false;
          auto call = id(status_led).turn_off();
          call.set_brightness(0.0f);
          call.set_rgb(0.0f, 0.0f, 0.0f);
          call.perform();
          id(led_enable_pin).turn_off();

  # Check every 2s; only sleep once 5s have passed so states propagate to HA
  - interval: 2s
    then:
      - lambda: |-
          if (id(sleep_sequence_active)) {
            // Wait at least 5 seconds for LED-off and device_awake states to reach HA
            unsigned long elapsed = millis() - id(sleep_sequence_start_time);
            if (elapsed < 5000) {
              ESP_LOGD("sleep", "Waiting for states to propagate (%lu ms elapsed)", elapsed);
              return;
            }

            // Guard again right before sleeping: if Wi-Fi dropped, abort sleep.
            if (!id(wifi_sta_connected)) {
              ESP_LOGW("wifi_gate", "Wi-Fi lost during sleep sequence; aborting sleep and re-enabling power rails");
              id(sleep_sequence_active) = false;
              id(device_awake) = true;
              id(sensor_enable_pin).turn_on();
              id(aht20_enable_pin).turn_on();
              id(led_enable_pin).turn_on();
              auto call2 = id(status_led).turn_on();
              call2.set_brightness(0.3f);
              call2.set_rgb(0.0f, 1.0f, 0.0f);
              call2.perform();
              return;
            }

            uint32_t sleep_time_ms = (uint32_t)id(sleep_duration_minutes) * 60u * 1000u;
            ESP_LOGI("sleep", "Going to sleep for %d minutes", id(sleep_duration_minutes));
            id(deep_sleep_component).set_sleep_duration(sleep_time_ms);
            id(deep_sleep_component).begin_sleep();
          }

i2c:
  sda: GPIO19
  scl: GPIO9
  scan: true
  id: bus_a

globals:
  - id: last_m1_value
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: last_m2_value
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: last_m3_value
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: sleep_duration_minutes
    type: int
    restore_value: true
    initial_value: '60'
  - id: sleep_disabled
    type: bool
    restore_value: true
    initial_value: 'true'
  - id: max_awake_minutes
    type: int
    restore_value: true
    initial_value: '120'
  - id: min_awake_minutes
    type: int
    restore_value: true
    initial_value: '1'
  - id: awake_start_time
    type: unsigned long
    restore_value: false
    initial_value: '0'
  - id: data_collection_complete
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: sensors_read_count
    type: int
    restore_value: false
    initial_value: '0'
  - id: ha_sleep_timer_active
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: sleep_sequence_active
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: sleep_sequence_start_time
    type: unsigned long
    restore_value: false
    initial_value: '0'
  - id: wifi_sta_connected
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: device_awake
    type: bool
    restore_value: false
    initial_value: 'true'

  # Sensor calibration values
  - id: sensor1_dry_value
    type: float
    restore_value: true
    initial_value: '1.979'
  - id: sensor1_wet_value
    type: float
    restore_value: true
    initial_value: '1.388'
  - id: sensor1_dry_timestamp
    type: std::string
    restore_value: true
    initial_value: '"Factory"'
  - id: sensor1_wet_timestamp
    type: std::string
    restore_value: true
    initial_value: '"Factory"'
  - id: sensor2_dry_value
    type: float
    restore_value: true
    initial_value: '1.979'
  - id: sensor2_wet_value
    type: float
    restore_value: true
    initial_value: '1.388'
  - id: sensor2_dry_timestamp
    type: std::string
    restore_value: true
    initial_value: '"Factory"'
  - id: sensor2_wet_timestamp
    type: std::string
    restore_value: true
    initial_value: '"Factory"'
  - id: sensor3_dry_value
    type: float
    restore_value: true
    initial_value: '2.046'
  - id: sensor3_wet_value
    type: float
    restore_value: true
    initial_value: '1.391'
  - id: sensor3_dry_timestamp
    type: std::string
    restore_value: true
    initial_value: '"Factory"'
  - id: sensor3_wet_timestamp
    type: std::string
    restore_value: true
    initial_value: '"Factory"'

output:
  - platform: gpio
    pin: GPIO6
    id: sensor_enable_pin
  - platform: gpio
    pin: GPIO7
    id: aht20_enable_pin
  - platform: gpio
    pin: GPIO18
    id: led_enable_pin

light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO10
    num_leds: 1
    chipset: ws2812
    name: "Status LED"
    id: status_led
    restore_mode: RESTORE_DEFAULT_OFF
    effects:
      - pulse:
          name: "Pulse"
          transition_length: 1s
          update_interval: 1s

sensor:
  # --- Moisture RAW ADCs (with NaN/drop + median) ---
  - platform: adc
    pin: GPIO1
    name: "Moisture 1 Raw Voltage"
    id: moisture_1
    update_interval: 5s
    attenuation: 11db
    filters:
      - skip_initial: 10
      - lambda: |-
          if (isnan(x)) {
            ESP_LOGW("adc_raw", "Moisture 1 NaN - dropped");
            return {};
          }
          if (x < 0.0f || x > 3.3f) {
            ESP_LOGW("adc_raw", "Moisture 1 out-of-range %.3fV - dropped", x);
            return {};
          }
          return x;
      - median:
          window_size: 5
          send_every: 1
          send_first_at: 1
      - delta: 0.01
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: "voltage"
    state_class: "measurement"
    on_value:
      - lambda: |-
          ESP_LOGD("adc_raw", "Moisture 1 raw ADC: %.3fV", x);

  - platform: adc
    pin: GPIO2
    name: "Moisture 2 Raw Voltage"
    id: moisture_2
    update_interval: 5s
    attenuation: 11db
    filters:
      - skip_initial: 10
      - lambda: |-
          if (isnan(x)) {
            ESP_LOGW("adc_raw", "Moisture 2 NaN - dropped");
            return {};
          }
          if (x < 0.0f || x > 3.3f) {
            ESP_LOGW("adc_raw", "Moisture 2 out-of-range %.3fV - dropped", x);
            return {};
          }
          return x;
      - median:
          window_size: 5
          send_every: 1
          send_first_at: 1
      - delta: 0.01
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: "voltage"
    state_class: "measurement"
    on_value:
      - lambda: |-
          ESP_LOGD("adc_raw", "Moisture 2 raw ADC: %.3fV", x);

  - platform: adc
    pin: GPIO3
    name: "Moisture 3 Raw Voltage"
    id: moisture_3
    update_interval: 5s
    attenuation: 11db
    filters:
      - skip_initial: 10
      - lambda: |-
          if (isnan(x)) {
            ESP_LOGW("adc_raw", "Moisture 3 NaN - dropped");
            return {};
          }
          if (x < 0.0f || x > 3.3f) {
            ESP_LOGW("adc_raw", "Moisture 3 out-of-range %.3fV - dropped", x);
            return {};
          }
          return x;
      - median:
          window_size: 5
          send_every: 1
          send_first_at: 1
      - delta: 0.01
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: "voltage"
    state_class: "measurement"
    on_value:
      - lambda: |-
          ESP_LOGD("adc_raw", "Moisture 3 raw ADC: %.3fV", x);

  # --- Power ADCs ---
  - platform: adc
    pin: GPIO0
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 30s
    attenuation: auto
    filters:
      - multiply: 2.5
      - sliding_window_moving_average:
          window_size: 3
          send_every: 1
    unit_of_measurement: "V"
    accuracy_decimals: 2
    device_class: "voltage"
    state_class: "measurement"

  - platform: adc
    pin: GPIO4
    name: "Solar Voltage"
    id: solar_voltage
    update_interval: 30s
    attenuation: auto
    filters:
      - multiply: 2.5
      - sliding_window_moving_average:
          window_size: 3
          send_every: 1
    unit_of_measurement: "V"
    accuracy_decimals: 2
    device_class: "voltage"
    state_class: "measurement"

  # --- Battery % ---
  - platform: template
    name: "Battery Percentage"
    id: battery_percentage
    lambda: |-
      float voltage = id(battery_voltage).state;
      if (voltage < 3.0f) return 0.0f;
      if (voltage > 4.2f) return 100.0f;
      return ((voltage - 3.0f) / (4.2f - 3.0f)) * 100.0f;
    unit_of_measurement: "%"
    accuracy_decimals: 0
    device_class: "battery"
    state_class: "measurement"
    update_interval: 30s

  # --- AHT20 ---
  - platform: aht10
    variant: AHT20
    address: 0x38
    temperature:
      name: "Temperature"
      id: aht20_temperature
      accuracy_decimals: 1
      device_class: "temperature"
      state_class: "measurement"
    humidity:
      name: "Humidity"
      id: aht20_humidity
      accuracy_decimals: 1
      device_class: "humidity"
      state_class: "measurement"
    update_interval: 60s

  # --- Misc sensors ---
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_signal_strength
    update_interval: 60s

  - platform: uptime
    name: "Uptime"
    id: uptime_sensor

  # --- Moisture % templates (publish NAN if raw is NaN) ---
  - platform: template
    name: "Moisture 1 Percentage"
    id: moisture_1_percent
    update_interval: 5s
    unit_of_measurement: "%"
    accuracy_decimals: 0
    device_class: "humidity"
    state_class: "measurement"
    lambda: |-
      float current = id(moisture_1).state;
      float dry = id(sensor1_dry_value);
      float wet = id(sensor1_wet_value);
      if (isnan(current)) {
        ESP_LOGW("moisture_calc", "Sensor 1: current NaN -> publishing NAN");
        return NAN;
      }
      float percentage = ((dry - current) / (dry - wet)) * 100.0f;
      if (percentage < 0.0f) percentage = 0.0f;
      if (percentage > 100.0f) percentage = 100.0f;
      return roundf(percentage / 5.0f) * 5.0f;

  - platform: template
    name: "Moisture 2 Percentage"
    id: moisture_2_percent
    update_interval: 5s
    unit_of_measurement: "%"
    accuracy_decimals: 0
    device_class: "humidity"
    state_class: "measurement"
    lambda: |-
      float current = id(moisture_2).state;
      float dry = id(sensor2_dry_value);
      float wet = id(sensor2_wet_value);
      if (isnan(current)) {
        ESP_LOGW("moisture_calc", "Sensor 2: current NaN -> publishing NAN");
        return NAN;
      }
      float percentage = ((dry - current) / (dry - wet)) * 100.0f;
      if (percentage < 0.0f) percentage = 0.0f;
      if (percentage > 100.0f) percentage = 100.0f;
      return roundf(percentage / 5.0f) * 5.0f;

  - platform: template
    name: "Moisture 3 Percentage"
    id: moisture_3_percent
    update_interval: 5s
    unit_of_measurement: "%"
    accuracy_decimals: 0
    device_class: "humidity"
    state_class: "measurement"
    lambda: |-
      float current = id(moisture_3).state;
      float dry = id(sensor3_dry_value);
      float wet = id(sensor3_wet_value);
      if (isnan(current)) {
        ESP_LOGW("moisture_calc", "Sensor 3: current NaN -> publishing NAN");
        return NAN;
      }
      float percentage = ((dry - current) / (dry - wet)) * 100.0f;
      if (percentage < 0.0f) percentage = 0.0f;
      if (percentage > 100.0f) percentage = 100.0f;
      return roundf(percentage / 5.0f) * 5.0f;

  # --- Sleep/Timing helpers ---
  - platform: template
    name: "Sleep Duration"
    id: current_sleep_duration_sensor
    lambda: |-
      return id(sleep_duration_minutes);
    unit_of_measurement: "min"
    accuracy_decimals: 0
    update_interval: 30s

  - platform: template
    name: "Time Awake"
    id: time_awake_sensor
    lambda: |-
      unsigned long awake_ms = millis() - id(awake_start_time);
      return awake_ms / (60 * 1000); // Convert to minutes
    unit_of_measurement: "min"
    accuracy_decimals: 0
    update_interval: 30s

binary_sensor:
  - platform: template
    name: "Solar Charging"
    id: solar_charging
    lambda: |-
      return id(solar_voltage).state > 1.0f;
    device_class: "battery_charging"

  - platform: template
    name: "Home Assistant Connected"
    id: ha_connected
    lambda: |-
      return id(api_server).is_connected();
    device_class: "connectivity"

  - platform: template
    name: "WiFi Connected"
    id: wifi_sta_connected_bin
    device_class: connectivity
    lambda: |-
      return id(wifi_sta_connected);

  - platform: template
    name: "Device Awake"
    id: device_awake_bin
    lambda: |-
      return id(device_awake);

number:
  - platform: template
    name: "Sleep Duration"
    id: sleep_duration_input
    icon: "mdi:sleep"
    min_value: 1
    max_value: 1440
    step: 1
    mode: box
    unit_of_measurement: "min"
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 60
    set_action:
      - lambda: |-
          if (x >= 1 && x <= 1440) {
            id(sleep_duration_minutes) = (int)x;
            ESP_LOGI("sleep", "Sleep duration updated to %d minutes", (int)x);
          }

  - platform: template
    name: "Max Awake Duration"
    id: max_awake_input
    icon: "mdi:timer-outline"
    min_value: 10
    max_value: 1440
    step: 5
    mode: box
    unit_of_measurement: "min"
    entity_category: "config"
    lambda: |-
      return id(max_awake_minutes);
    set_action:
      - lambda: |-
          if (x >= 10 && x <= 1440) {
            id(max_awake_minutes) = (int)x;
            ESP_LOGI("sleep", "Max awake duration updated to %d minutes", (int)x);
          } else {
            ESP_LOGI("sleep", "Invalid max awake duration: %d minutes", (int)x);
          }

  - platform: template
    name: "Min Awake Duration"
    id: min_awake_input
    icon: "mdi:timer-sand"
    min_value: 0
    max_value: 15
    step: 1
    mode: box
    unit_of_measurement: "min"
    entity_category: "config"
    lambda: |-
      return id(min_awake_minutes);
    set_action:
      - lambda: |-
          id(min_awake_minutes) = (int)x;
          ESP_LOGI("sleep", "Min awake updated to %d min", (int)x);

switch:
  - platform: template
    name: "Disable Sleep"
    id: sleep_disable_switch
    icon: "mdi:sleep-off"
    entity_category: "config"
    lambda: |-
      return id(sleep_disabled);
    turn_on_action:
      - lambda: |-
          id(sleep_disabled) = true;
          id(awake_start_time) = millis(); // Reset awake timer when disabling sleep
          ESP_LOGI("sleep", "Sleep disabled by user");
    turn_off_action:
      - lambda: |-
          id(sleep_disabled) = false;
          ESP_LOGI("sleep", "Sleep enabled by user");

button:
  - platform: template
    name: "Sleep Now"
    id: sleep_now_button
    icon: "mdi:power-sleep"
    on_press:
      - logger.log: "MANUAL SLEEP REQUESTED"
      # Refuse manual sleep if Wi-Fi is not connected
      - lambda: |-
          if (!id(wifi_sta_connected)) {
            ESP_LOGW("wifi_gate", "Refusing manual sleep: STA Wi-Fi not connected");
            return;
          }
          id(sleep_disabled) = false; // Force enable sleep
          id(ha_sleep_timer_active) = false;
          id(sleep_sequence_active) = true;
          id(sleep_sequence_start_time) = millis();
          id(last_m1_value) = id(moisture_1).state;
          id(last_m2_value) = id(moisture_2).state;
          id(last_m3_value) = id(moisture_3).state;
          ESP_LOGI("sleep", "Manual sleep - saved M1=%.3f, M2=%.3f, M3=%.3f", id(last_m1_value), id(last_m2_value), id(last_m3_value));
      - output.turn_off: sensor_enable_pin
      - output.turn_off: aht20_enable_pin
      # Turn off LED and mark device asleep before the delay so states propagate to HA
      - lambda: |-
          id(device_awake) = false;
          auto call = id(status_led).turn_off();
          call.set_brightness(0.0f);
          call.set_rgb(0.0f, 0.0f, 0.0f);
          call.perform();
          id(led_enable_pin).turn_off();
      - delay: 5s
      - logger.log: "*** MANUAL SLEEP: GOING TO SLEEP NOW ***"
      - lambda: |-
          // Final Wi-Fi guard just before sleep
          if (!id(wifi_sta_connected)) {
            ESP_LOGW("wifi_gate", "Wi-Fi lost before manual sleep begin; canceling sleep");
            id(sleep_sequence_active) = false;
            id(device_awake) = true;
            id(led_enable_pin).turn_on();
            auto call2 = id(status_led).turn_on();
            call2.set_brightness(0.3f);
            call2.set_rgb(0.0f, 1.0f, 0.0f);
            call2.perform();
            return;
          }

          uint32_t sleep_time_ms = (uint32_t)id(sleep_duration_minutes) * 60u * 1000u;
          ESP_LOGI("sleep", "Manual sleep for %d minutes", id(sleep_duration_minutes));
          id(deep_sleep_component).set_sleep_duration(sleep_time_ms);
          id(deep_sleep_component).begin_sleep();

  - platform: template
    name: "Factory Reset Calibration"
    id: factory_reset_calibration_button
    icon: "mdi:factory"
    on_press:
      - lambda: |-
          id(sensor1_dry_value) = 1.979f;
          id(sensor1_wet_value) = 1.388f;
          id(sensor1_dry_timestamp) = "Factory";
          id(sensor1_wet_timestamp) = "Factory";
          id(sensor2_dry_value) = 1.979f;
          id(sensor2_wet_value) = 1.388f;
          id(sensor2_dry_timestamp) = "Factory";
          id(sensor2_wet_timestamp) = "Factory";
          id(sensor3_dry_value) = 2.046f;
          id(sensor3_wet_value) = 1.391f;
          id(sensor3_dry_timestamp) = "Factory";
          id(sensor3_wet_timestamp) = "Factory";
          ESP_LOGI("calibration", "Factory reset completed");

  - platform: template
    name: "Calibrate Moisture 1 Dry"
    id: calibrate_moisture_1_dry_button
    icon: "mdi:water-minus"
    on_press:
      - lambda: |-
          float current_voltage = id(moisture_1).state;
          id(sensor1_dry_value) = current_voltage;
          auto time = id(homeassistant_time).now();
          if (time.is_valid()) {
            char timestamp[64];
            sprintf(timestamp, "%04d-%02d-%02d %02d:%02d:%02d",
                   time.year, time.month, time.day_of_month,
                   time.hour, time.minute, time.second);
            id(sensor1_dry_timestamp) = std::string(timestamp);
          } else {
            id(sensor1_dry_timestamp) = "Time not available";
          }
          ESP_LOGI("calibration", "Sensor 1 dry calibrated: %.3fV", current_voltage);

  - platform: template
    name: "Calibrate Moisture 1 Wet"
    id: calibrate_moisture_1_wet_button
    icon: "mdi:water-plus"
    on_press:
      - lambda: |-
          float current_voltage = id(moisture_1).state;
          id(sensor1_wet_value) = current_voltage;
          auto time = id(homeassistant_time).now();
          if (time.is_valid()) {
            char timestamp[64];
            sprintf(timestamp, "%04d-%02d-%02d %02d:%02d:%02d",
                   time.year, time.month, time.day_of_month,
                   time.hour, time.minute, time.second);
            id(sensor1_wet_timestamp) = std::string(timestamp);
          } else {
            id(sensor1_wet_timestamp) = "Time not available";
          }
          ESP_LOGI("calibration", "Sensor 1 wet calibrated: %.3fV", current_voltage);

  - platform: template
    name: "Calibrate Moisture 2 Dry"
    id: calibrate_moisture_2_dry_button
    icon: "mdi:water-minus"
    on_press:
      - lambda: |-
          float current_voltage = id(moisture_2).state;
          id(sensor2_dry_value) = current_voltage;
          auto time = id(homeassistant_time).now();
          if (time.is_valid()) {
            char timestamp[64];
            sprintf(timestamp, "%04d-%02d-%02d %02d:%02d:%02d",
                   time.year, time.month, time.day_of_month,
                   time.hour, time.minute, time.second);
            id(sensor2_dry_timestamp) = std::string(timestamp);
          } else {
            id(sensor2_dry_timestamp) = "Time not available";
          }
          ESP_LOGI("calibration", "Sensor 2 dry calibrated: %.3fV", current_voltage);

  - platform: template
    name: "Calibrate Moisture 2 Wet"
    id: calibrate_moisture_2_wet_button
    icon: "mdi:water-plus"
    on_press:
      - lambda: |-
          float current_voltage = id(moisture_2).state;
          id(sensor2_wet_value) = current_voltage;
          auto time = id(homeassistant_time).now();
          if (time.is_valid()) {
            char timestamp[64];
            sprintf(timestamp, "%04d-%02d-%02d %02d:%02d:%02d",
                   time.year, time.month, time.day_of_month,
                   time.hour, time.minute, time.second);
            id(sensor2_wet_timestamp) = std::string(timestamp);
          } else {
            id(sensor2_wet_timestamp) = "Time not available";
          }
          ESP_LOGI("calibration", "Sensor 2 wet calibrated: %.3fV", current_voltage);

  - platform: template
    name: "Calibrate Moisture 3 Dry"
    id: calibrate_moisture_3_dry_button
    icon: "mdi:water-minus"
    on_press:
      - lambda: |-
          float current_voltage = id(moisture_3).state;
          id(sensor3_dry_value) = current_voltage;
          auto time = id(homeassistant_time).now();
          if (time.is_valid()) {
            char timestamp[64];
            sprintf(timestamp, "%04d-%02d-%02d %02d:%02d:%02d",
                   time.year, time.month, time.day_of_month,
                   time.hour, time.minute, time.second);
            id(sensor3_dry_timestamp) = std::string(timestamp);
          } else {
            id(sensor3_dry_timestamp) = "Time not available";
          }
          ESP_LOGI("calibration", "Sensor 3 dry calibrated: %.3fV", current_voltage);

  - platform: template
    name: "Calibrate Moisture 3 Wet"
    id: calibrate_moisture_3_wet_button
    icon: "mdi:water-plus"
    on_press:
      - lambda: |-
          float current_voltage = id(moisture_3).state;
          id(sensor3_wet_value) = current_voltage;
          auto time = id(homeassistant_time).now();
          if (time.is_valid()) {
            char timestamp[64];
            sprintf(timestamp, "%04d-%02d-%02d %02d:%02d:%02d",
                   time.year, time.month, time.day_of_month,
                   time.hour, time.minute, time.second);
            id(sensor3_wet_timestamp) = std::string(timestamp);
          } else {
            id(sensor3_wet_timestamp) = "Time not available";
          }
          ESP_LOGI("calibration", "Sensor 3 wet calibrated: %.3fV", current_voltage);
